##### Contributor: 吴凭飞  

##### Student ID: 2018011366

 注：该项目为作者未接触面向对象编程时写的，所以写法有些不符合oop标准

一． 项目介绍：

该项目为一个简单的拼图复原游戏，作者在写大一上学期程设大作业（八数码复原问题）时，未选择通用的启发式算法，而是根据自己玩拼图游戏遵循的规则来编写拼图复原程序，简称人脑式算法，该算法在解决类八数码问题的效率远高于启发式算法。

二． 编译环境

Dev C++

三． 关键函数说明

1.read.h：

（1）函数功能：读图函数，将bmp图片的位图信息储存在pBmpBuf字符数组里。

​      （2）函数工作原理：引入头文件windows.h后bmp图片头文件结构已被定义为BITMAPFILEHEADER，直接跳过bmp图片的头文件使用fread函数读取位图信息。

2.save.h：

（1）函数功能：存图函数，利用pBmpBuf(及pBmpBuf0，pBmpBuf1)字符数组里的信息生成新的图片。

（2）函数工作原理：

a)先新建立bmp图片头文件类型变量（已在windows.h中定义），先将字符数组中提供的图片长宽，每个像素占多少字节等基本信息存入指定文件；

b)再新建立位图信息头结构型变量（已在windows.h中定义），将像素的基本信息存入指定文件；

c)最后将具体的位图信息存入指定的文件内，生成新的图片。

3.feasibility.h：

（1）函数功能：判断图片方块打乱顺序后能否复原的函数。

  （2）函数工作原理：

​       a)若图片分块的矩阵列数为奇数，则空格上下左右移动不改变整个矩阵在宽度上的逆序数的奇偶性；

​       b)若图片分块的矩阵列数为偶数，则空格上下移动会改变整个矩阵在宽度上的逆序数的奇偶性，所以当空格距离最后一行的垂直距离为奇数时，逆序数奇偶性改变，而当空格距离最后一行的垂直距离为偶数时，逆序数奇偶性不变。

4.test1.h:

（1）函数功能：判断当前状态矩阵前N-2行是否复原的函数；

（2）函数工作原理：比较当前状态矩阵now[]的前N-2行是否与初始状态顺序一样。

5.test2.h:

（1）函数功能：判断当前状态矩阵第N-1行至第N行，前N-2列是否复原的函数；

（2）函数工作原理：比较当前状态矩阵now[]的第N-1行至第N行，前N-2列是否与初始状态顺序一样。

6.test.h:

（1）函数功能：判断当前状态矩阵是否能够完全复原的函数；

（2）函数工作原理：比较当前状态矩阵now[]是否与初始状态顺序完全一样。

7.W.h:

（1）函数功能：将空格上方的小块下移，并输出“W”；

（2）函数工作原理：

a)先对图片分块相应的矩阵进行操作，交换两个矩阵方块对应的数值；

b)再对储存图片位图信息的字符数组进行操作，通过坐标变化，将这两个方块对应的所有像素的信息进行交换；

c)输出“W”；

d)操作数step++；

8.S.h:

（1）函数功能：将空格下方的小块上移，并输出“S”。

（2）函数工作原理：同W.h。

9.A.h:

（1）函数功能：将空格左方的小块右移，并输出“A”。

（2）函数工作原理：同W.h。

10.D.h:

（1）函数功能：将空格右方的小块左移，并输出“D”。

（2）函数工作原理：同W.h。

复原拼图游戏示意图   

| A    | B    |
| ---- | ---- |
| C    | D    |

11.复原函数（autorecover.h，autorecover1.h，autorecover2.h）：

（1）复原思路：在介绍复原函数之前，我想我有必要介绍一下我的复原思路。

​     a)一开始做拼图复原工作我想到的是用宽度搜索结合启发式算法的方法（计算机科学导论课上史元春老师介绍的），但是经过一天的奋斗发现写出来的程序居然跑5*5的矩阵都很慢。我分析是因为每一步都有至多三种至少一种的可能步骤，搜索需要分析大量的可能情况，虽然有启发式算法能有效剪枝，但仍较复杂。

​     b)所以我决定换一种思路，让计算机自己知道怎么去复原拼图，而不是用碰运气的方法来复原拼图，简单点说就是人脑式算法，即一行一行地去复原，让计算机的每一步操作都是有目的的。复原函数程序中大多由if（）判断句组成，实际运算速度很快。

​     c)人脑式算法复原拼图要分为四部分完成，如上图所示：

​       A代表前N-2行,前N-2列；

​       B代表前N-2行,第N-1列至第N列；

​       C代表第N-1行至第N行，前N-2列；

​       D代表最后2行，最后2列。

​       整体过程如下：

前N-2行的复原中A和B部分的复原交替进行（分别使用autorecover.h函数和autorecover1.h函数）；

​      复原到C部分时使用autorecover2.h函数；

​      最后的D部分让空格顺时针转圈直至完全复原。

（2）各部分复原函数：

autorecover.h:

a）函数功能：用于复原前N-2行，前N-2列的矩阵方块；

​                  b）复原思路：复原思路：一行一行逐个逐个地去复原（将目标方块放到它原本的位置即复原）

c）复原方法：c1）先分类讨论（利用空格与目标方块位置关系分类）：

空格在目标方块上方（空格在左上方，右上方，正上方）；

空格在目标方块下方（空格在左下方，右下方，正下方）；

空格与目标方块同行（空格在左方，右方）

c2）再控制空格移动将目标方块移至目标位置。

autorecover1.h：

a）函数功能：用于复原前N-2行，第N-1至N列的方块

 b）复原思路：b1）先将第i行，第N列的方块移动到第i行，第N-1列；

​                         b2）再将第i行，第N-1列的方块移动到第i+1行，第N-1列；

​                         b3）然后将空格移至第i行，第N列；

​                         b4）最后控制方块顺时针转动即可复原第i行第N-1 列和第i行第N列；

autorecover2.h：

a）函数功能用于复原第N-1至N行，前N-2列的方块

​          b）复原思路：同autorecover2.h

四． 附加功能

\1.  记录操作数：

复原过程中的W,A,S,D函数都会使操作数对应的变量step加一，而在游戏中，玩家输入的W,A,S,D指令也会使step加一，在每一个指令执行后都会输出此时的操作数。

\2.  游戏中含三个存档（file1,2,3）

（1）   玩家可任意存储当前进度进这三个存档，并可以随意调用这三个存档；

（2）   如果玩家调用了未储存进度的空存档或其他（非1,2,3）存档，程序会提示：该存档为空，请重新输入你要调用的存档名，或可以输入0，取消调用操作；

（3）   如果玩家想存储当前进度进其他存档（非1,2,3），程序会提示：该存档不存在，请重新输入你要存入的存档名，或可以输入0，取消存档操作；

五．人脑式复原算法的优点：
     1.相比于基于搜索的算法，人脑式算法能让计算机有目的地去复原，它的每一步操作都是有理由的，这实际上是最高效的剪枝方法，因为计算机不会列举其他任何不符合它目的的操作，简而言之，就是省略了判断下一步该怎么走的过程，计算机通过当前空白格与目标方块的位置可直接唯一确定下一步的操作。

2.我尝试运算200*200的矩阵，如果使用打表的方法可以在半分钟内完成整个复原过程，但因为作业要求复原步骤需要呈现在程序页面上，所以我使用cout来输出，会比打表的速度慢很多。

六．我的测试（未用专业测时的程序测时，仅供参考）：

10*10难度（100次）：cout约1至2秒完成，打表可瞬间完成，操作数在4000以内;

50*50难度（10次）：cout约1分钟，打表也可很快完成，操作数在十万级；

200*200难度（10次）：cout约二三十分钟，打表半分钟内完成，操作数在百万级。

七．总结：

该项目具有读取任一8位和24位的bmp图片文件，并实现拼图游戏各基本操作的功能。

另：游戏操作说明见“简单的游戏中文说明”文件

 